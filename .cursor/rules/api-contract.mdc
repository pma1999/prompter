---
description: Refine API request/response contracts for backend integration
---
# Refine API Contract (v1)

Types are defined in [frontend/src/domain/types.ts](mdc:frontend/src/domain/types.ts).

## Request: POST /api/refine

- Body: `RefineRequest`
  - `modelId`: `gemini-2.5-pro | gemini-2.5-flash | gemini-2.5-flash-image`
  - `family`: `text | image`
  - `rawPrompt`: string
  - `instructionPresetId`: string (derived in frontend, not editable by user)
  - `answers?`: array of `{ questionId, optionId }`
  - `context?.image?`: `{ workflow: "generate"|"edit"|"compose", assets?: AssetRef[] }`
  - `cache?`: `{ mode?: "off"|"implicit_only"|"explicit_per_request"|"explicit_per_conversation", cachedContentName?: string, key?: string, ttlSeconds?: number, forceRefresh?: boolean }`
  - `client?`: `{ appVersion?, schemaVersion? }`

## Response: 200 OK `RefineResponse`

- `status`: `ready | needs_clarification | error`
- `previewPrompt?`: present for recommendations preview
- `perfectedPrompt?`: present when ready
- `questions?`: array with `recommended` option and optional `why`
- `recommendedAnswers?`: recommended option ids
- `schemaVersion`: `v1`
- `usage?`: detailed usage bundle aggregated by the server
  - Shape: `RefineUsageBundle` with optional entries per sub-call and an `aggregate` sum:
    - `primary?`, `preview?`, `final?`, `previewFallback?`: each is `UsageMetadata`
    - `aggregate?`: sum of numeric fields across present entries
  - `UsageMetadata` fields (camelCase, snake_case tolerated from upstream):
    - `promptTokenCount?`, `candidatesTokenCount?`, `totalTokenCount?`, `cachedContentTokenCount?`, `thoughtsTokenCount?`
    - `promptTokensDetails?`, `cacheTokensDetails?`: arrays of `{ modality, tokenCount }`
- `cache?`:
  - Explicit path: `{ mode: "explicit", cachedContentName?: string, key?: string, expireTime?: string, created?: boolean }`
  - Implicit path: `{ mode: "implicit_only", usage?: { cachedTokens?: number, totalTokenCount?: number } }` (legacy/minimal; prefer `RefineResponse.usage`)

Validate responses with zod prior to updating UI state.

## Request: POST /api/tokens/count

- Purpose: preflight counting using Gemini `models.countTokens` with the exact `contents` that the next refine call would send.
- Body: same shape as `RefineRequest`, plus optional `includeCachedPrefix?: boolean`.
  - In explicit cache mode without an existing cache, both the would-be cached prefix and the dynamic suffix are counted separately.
- Response: `TokenCountResponse`
  - `totalTokens`: number (input tokens for the upcoming call)
  - `cachedContentTokenCount?`: number (tokens of the cached prefix when requested/available)
  - `promptTokensDetails?`, `cacheTokensDetails?`: arrays of `{ modality, tokenCount }`

